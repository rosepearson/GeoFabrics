:py:mod:`geofabrics.dem`
========================

.. py:module:: geofabrics.dem

.. autoapi-nested-parse::

   This module contains classes associated with loading, generating, and combining
   DEMs.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   geofabrics.dem.CoarseDem
   geofabrics.dem.DemBase
   geofabrics.dem.HydrologicallyConditionedDem
   geofabrics.dem.LidarBase
   geofabrics.dem.RawDem
   geofabrics.dem.RoughnessDem



Functions
~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.read_file_with_pdal
   geofabrics.dem.roughness_from_points
   geofabrics.dem.elevation_from_points
   geofabrics.dem.calculate_idw
   geofabrics.dem.calculate_linear
   geofabrics.dem.load_tiles_in_chunk
   geofabrics.dem.roughness_over_chunk
   geofabrics.dem.elevation_over_chunk



Attributes
~~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.delayed_roughness_over_chunk
   geofabrics.dem.delayed_elevation_over_chunk


.. py:class:: CoarseDem(dem_file, catchment_geometry, set_foreshore = True, extent = None)


   A class to manage coarse or background DEMs in the catchment context

   Specifically, clip within the catchment land and foreshore. There is the option to
   clip outside any LiDAR using the
   optional 'exclusion_extent' input.

   If set_foreshore is True all positive DEM values in the foreshore are set to zero.

   .. py:property:: dem
      :type: xarray.Dataset

      Return the DEM over the catchment region

   .. py:property:: resolution
      :type: float

      Return the largest dimension of the coarse DEM resolution

   .. py:property:: points
      :type: numpy.ndarray

      The coarse DEM points after any extent or foreshore value
      filtering.

   .. py:property:: extents
      :type: geopandas.GeoDataFrame

      The extents for the coarse DEM

   .. py:property:: empty
      :type: bool

      True if the DEM is empty

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: chunk_points(chunk)

      The coarse DEM points after any extent or foreshore value
      filtering.



.. py:class:: DemBase(catchment_geometry)


   Bases: :py:obj:`abc.ABC`

   An abstract class to manage the different geofabric layers in a
   catchment context. The geofabruc has a z, and data_source layer and may
   sometimes also have a zo (roughness length) and lidar_source layer.

   It is represented by an XArray dataset and is expected to be saved as a
   netCDF file.

   Standard data catcegories are specified in the SOURCE_CLASSIFICATION
   variable.

   :param catchment_geometry: Defines the spatial extents of the catchment, land, foreshore, and offshore
                              regions
   :param extents: Defines the extents of any dense (LiDAR or refernence DEM) values already added.

   .. py:property:: dem
      :type: xarray.Dataset
      :abstractmethod:

      Return the DEM over the catchment region


.. py:class:: HydrologicallyConditionedDem(catchment_geometry, raw_dem_path, interpolation_method)


   Bases: :py:obj:`DemBase`

   A class to manage loading in an already created and saved dense DEM that has yet
   to have an offshore DEM associated with it.

   :param Logic controlling behaviour:
                                       interpolation_method
                                           If not None, interpolate using that method. Valid options are 'linear',
                                           'nearest', and 'cubic'

   .. py:property:: raw_extents

      Return the combined DEM from tiles and any interpolated offshore values

   .. py:property:: dem

      Return the combined DEM from tiles and any interpolated offshore values

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: combine_dem_parts()

      Return the combined DEM from all layers that exist.


   .. py:method:: interpolate_bathymetry_points(bathymetry_points, flat_x_array, flat_y_array, method)

      Interpolate the bathymetry points at the specified locations using the
      specified method.


   .. py:method:: interpolate_ocean_bathymetry(bathy_contours)

      Performs interpolation offshore outside LiDAR extents using the SciPy RBF
      function.


   .. py:method:: interpolate_waterbed_elevations(estimated_bathymetry)

      Performs interpolation over drains, culverts, rivers and river fan
      polygons using various interpolation techniques.



.. py:class:: LidarBase(catchment_geometry, elevation_range = None)


   Bases: :py:obj:`DemBase`

   A class with some base methods for reading in LiDAR data.

   :param catchment_geometry: Defines the geometry of the catchment
   :param elevation_range: The range of valid LiDAR elevations. i.e. define elevation filtering to apply.

   .. py:property:: dem

      Return the combined DEM from tiles and any interpolated offshore values

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: add_lidar(lidar_datasets_info, chunk_size, lidar_classifications_to_keep, metadata)
      :abstractmethod:

      Read in all LiDAR files and use to create a 'raw' DEM.

      :param lidar_datasets_info: A dictionary of information for each specified LIDAR dataset - For
                                  each this includes: a list of LAS files, CRS, and tile index file.
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM - must include
                        `dataset_mapping` key if datasets (not a single LAZ file) included.



.. py:class:: RawDem(catchment_geometry, lidar_interpolation_method, drop_offshore_lidar = True, elevation_range = None)


   Bases: :py:obj:`LidarBase`

   A class to manage the creation of a 'raw' DEM from LiDAR tiles, and/or a
   coarse DEM.

   :param drop_offshore_lidar: If True only keep LiDAR values within the foreshore and land regions defined by
                               the catchment_geometry. If False keep all LiDAR values.
   :param elevation_range: Optitionally specify a range of valid elevations. Any LiDAR points with
                           elevations outside this range will be filtered out.
   :param lidar_interpolation_method: The interpolation method to apply to LiDAR during downsampling/averaging.
                                      Options are: mean, median, IDW, max, min, STD.

   .. py:method:: add_lidar(lidar_datasets_info, chunk_size, lidar_classifications_to_keep, metadata)

      Read in all LiDAR files and use to create a 'raw' DEM.

      :param lidar_datasets_info: A dictionary of information for each specified LIDAR dataset - For
                                  each this includes: a list of LAS files, CRS, and tile index file.
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM - must include
                        `dataset_mapping` key if datasets (not a single LAZ file) included.


   .. py:method:: add_coarse_dems(coarse_dem_paths, area_threshold, buffer_cells, chunk_size)

      Check if area requring infill, if so iterate through coarse DEMs
      adding missing detail.

      Currently doesn't use chunking - this may be required if a large area is covered
      by the coarse DEM.

      :param coarse_dem_paths - list of coarse DEM file paths to try add in turn:
      :param area_threshold - the ratio of area without LiDAR required to for: coarse DEMs to be used.
      :param buffer_cells - the number of empty cells to keep around LiDAR cells: for interpolation after the coarse DEM added to ensure a smooth
                                                                                  boundary.


   .. py:method:: add_coarse_dem_no_chunking(coarse_dem, region_to_rasterise, mask)

      Fill gaps in dense DEM from areas with no LiDAR with the coarse DEM.
      Perform linear interpolation.

      :param coarse_dem - The coarse DEM to use for rasterising:
      :param region_to_rasterise - the area to rasterise using the coarse DEM:


   .. py:method:: add_coarse_dem_chunked(coarse_dem, region_to_rasterise, chunk_size, mask)

      Fill gaps in dense DEM from areas with no LiDAR with the coarse DEM.
      Perform linear interpolation.

      :param coarse_dem - The coarse DEM to use for rasterising:
      :param region_to_rasterise - the area to rasterise using the coarse DEM:
      :param chunk_size - the size of each chunk:



.. py:class:: RoughnessDem(catchment_geometry, hydrological_dem_path, interpolation_method, elevation_range = None)


   Bases: :py:obj:`LidarBase`

   A class to add a roughness (zo) layer to a hydrologically conditioned DEM.

   They STD and mean height of ground cover classified points are calculated from the
   LiDAR data and z (elevation) layer of the hydrologically conditioned DEM, and used
   to estimate roughness emperically.

   RoughnessDem logic can be controlled by the constructor inputs.

   :param catchment_geometry: Defines the geometry of the catchment
   :param hydrological_dem_path: The path to the hydrologically conditioned DEM.
   :param interpolation_method: If not None, interpolate using that method. Valid options are 'linear',
                                'nearest', and 'cubic'.
   :param lidar_interpolation_method: The interpolation method to apply to LiDAR. Options are: mean, median, IDW.

   .. py:method:: add_lidar(lidar_datasets_info, chunk_size, lidar_classifications_to_keep, metadata)

      Read in all LiDAR files and use the point cloud distribution,
      data_source layer, and hydrologiaclly conditioned elevations to
      estimate the roughness across the DEM.

      :param lidar_datasets_info: A dictionary of information for each specified LIDAR dataset - For
                                  each this includes: a list of LAS files, CRS, and tile index file.
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM - must include
                        `dataset_mapping` key if datasets (not a single LAZ file) included.



.. py:function:: read_file_with_pdal(lidar_file, region_to_tile, crs, source_crs = None)

   Read a tile file in using PDAL with input and output CRS specified.


.. py:function:: roughness_from_points(point_cloud, xy_out, xy_ground, options, eps = 0, leaf_size = 10)

   Calculate DEM elevation values at the specified locations using the selected
   approach. Options include: mean, median, and inverse distance weighing (IDW). This
   implementation is based on the scipy.spatial.KDTree


.. py:function:: elevation_from_points(point_cloud, xy_out, options, eps = 0, leaf_size = 10)

   Calculate DEM elevation values at the specified locations using the selected
   approach. Options include: mean, median, and inverse distance weighing (IDW). This
   implementation is based on the scipy.spatial.KDTree


.. py:function:: calculate_idw(near_indices, point, tree, point_cloud, smoothing = 0, power = 2)

   Calculate the IDW mean of the 'near_indices' points. This implementation is based
   on the scipy.spatial.KDTree


.. py:function:: calculate_linear(near_indices, point, tree, point_cloud)

   Calculate linear interpolation of the 'near_indices' points. Take the straight
   mean if the points are co-linear or too few for linear interpolation.


.. py:function:: load_tiles_in_chunk(lidar_files, source_crs, chunk_region_to_tile, crs)

   Read in all LiDAR files within the chunked region - clipped to within
   the region within which to rasterise.


.. py:function:: roughness_over_chunk(dim_x, dim_y, tile_points, xy_ground, options)

   Rasterise all points within a chunk.


.. py:function:: elevation_over_chunk(dim_x, dim_y, tile_points, options)

   Rasterise all points within a chunk.


.. py:data:: delayed_roughness_over_chunk

   Wrap the `rasterise_chunk` routine in dask.delayed

.. py:data:: delayed_elevation_over_chunk

   Wrap the `load_tiles_in_chunk` routine in dask.delayed

